---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.1
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# What happens when I use ZNE?

In Mitiq, ZNE is clearly divided into two steps, noise scaling and extrapolation. They are shown in the Figure below. As mentioned in the [introduction to ZNE](zne-1-intro.myst),
the corresponding sub-modules in the codebase are {mod}`mitiq.zne.scaling.folding` and {mod}`mitiq.zne.inference`.

```{figure} ../img/zne_workflow2_steps.png
---
width: 400
name: figzne
---
The diagram shows the workflow of the zero noise extrapolation (ZNE) techniques in Mitiq. 
```

**The first step** involves generating quantum circuits for noise scaling. 
  - The user provides a `QPROGRAM`, (i.e. a quantum circuit defined via any of the supported frontends).
  - Mitiq generates a scaled circuit via unitary folding. This step depends on the scale factor provided by the user as scale factor dictates the number of gates
  inserted.
  - The circuit is executed on a backend for different scale factors.

**The second step** involves inferring the zero-noise value from the noisy circuit measurements.
  - Using a range of noisy expectation values calculated at different scale factors, user chosen classical extrapolation will infer an ideal noiseless expectation
  value.
  - The error mitigated expectation vaue is returned by Mitiq. 

As demonstrated in [How do I use ZNE ?](zne-1-intro.myst), {func}`.execute_with_zne()` can be used for using methods defined in Mitiq. However, if one chooses to
customize the process, an interested reader will find in the sections below content useful to understand how to customize noise scaling methods and how a
factory object actually works at a deeper level.

+++

## Custom folding methods

If a user chooses to define a custom folding method, then an input circuit will have to be initialized as defined in [How do I use ZNE ?](zne-1-intro.myst). A user 
can choose to define a custom inference method or use methods defined in Mitiq.

Custom folding methods can be defined and used with Mitiq, e.g., with {py:func}`.zne.execute_with_zne`. The signature of this function must be as follows:

```{code-cell} ipython3
import cirq
from mitiq.interface.conversions import atomic_converter

@atomic_converter
def my_custom_folding_function(circuit: cirq.Circuit, scale_factor: float) -> cirq.Circuit:
    # Insert custom folding method here
    return folded_circuit
```

:::{note}
The `converter` decorator makes it so `my_custom_folding_function`
can be used with any supported circuit type, not just Cirq circuits.
The body of the `my_custom_folding_function` should assume the input
circuit is a Cirq circuit, however.
:::

This function can then be used with `.zne.execute_with_zne` as an option to scale the noise:

```{code-cell} ipython3
# Variables circuit and scale_noise are a circuit to fold and a scale factor, respectively

#zne = mitiq.zne.execute_with_zne(circuit, executor=my_custom_folding_function, scale_noise=my_custom_folding_function)
```

## Advanced usage of a factory

In this advanced section we present a low-level usage of a factory and we
also discuss how the user can easily define a custom factory class.

+++

### Low-level usage: the `run_classical` method.

The {py:meth}`.inference.Factory.run` method takes as arguments a circuit and other "quantum" objects.
On the other hand, the core computation performed by any factory corresponds to
a some classical computation applied to the measurement results.

At a lower level, it is possible to clearly separate the quantum and the
classical steps of a zero-noise extrapolation procedure.
This can be done by defining a function which maps a noise scale factor to the
corresponding expectation value.

```{code-cell} ipython3
import numpy as np
from cirq import Circuit, depolarize, DensityMatrixSimulator
from mitiq.zne.scaling import fold_gates_at_random

# initialize a backend
SIMULATOR = DensityMatrixSimulator()
# 5% depolarizing noise
NOISE = 0.05

def executor(circ: Circuit) -> float:
   """Executes a circuit with depolarizing noise and
   returns the expectation value of the projector |0><0|."""
   circuit = circ.with_noise(depolarize(p=NOISE))
   rho = SIMULATOR.simulate(circuit).final_density_matrix
   obs = np.diag([1, 0])
   expectation = np.real(np.trace(rho @ obs))
   return expectation

def noise_to_expval(scale_factor: float) -> float:
    """Function returning an expectation value for a given scale_factor."""
    # apply noise scaling
    scaled_circuit = fold_gates_at_random(circuit, scale_factor)
    # return the corresponding expectation value
    return executor(scaled_circuit)
```

```{code-cell} ipython3
import numpy as np
from cirq import Circuit, depolarize, DensityMatrixSimulator
from cirq import LineQubit, X, H

q = LineQubit(0)
circuit = Circuit(H(q), X(q), H(q), H(q), X(q), H(q))
expval = executor(circuit)
exact = 1.0
print(f"The ideal result should be {exact}")
print(f"The real result is {expval:.4f}")
print(f"The abslute error is {abs(exact - expval):.4f}")
```

:::{note}
The body of the previous function contains the execution of a quantum circuit.
However, if we see it as a "black-box", it is just a classical function mapping real
numbers to real numbers.
:::

The function {func}`.noise_to_expval` encapsulate the "quantum part" of the problem. The "classical
part" of the problem can be solved by passing {func}`noise_to_expval` to the {meth}`.Factory.run_classical` method of a factory.
This method will repeatedly call `noise_to_expval` for different
noise levels, so one can view `self.run_classical` as the classical counterpart of the quantum method
`self.run`. This method is present also for {meth}`.AdaptiveFactory.run_classical` and {meth}`.BatchedFactory.run_classical`.

```{code-cell} ipython3
from mitiq.zne.inference import LinearFactory, RichardsonFactory, PolyFactory

# method: scale noise by 1 and 2, then extrapolate linearly to the zero noise limit.
linear_fac = LinearFactory(scale_factors=[1.0, 2.0])

# method: scale noise by 1, 2 and 3, then evaluate the Richardson extrapolation.
richardson_fac = RichardsonFactory(scale_factors=[1.0, 2.0, 3.0])

# method: scale noise by 1, 2, 3, and 4, then extrapolate quadratically to the zero noise limit.
poly_fac = PolyFactory(scale_factors=[1.0, 2.0, 3.0, 4.0], order=2)
```

```{code-cell} ipython3
linear_fac.run_classical(noise_to_expval)
zne_expval = linear_fac.reduce()
print(f"Error with linear_fac: {abs(exact - zne_expval):.4f}")

richardson_fac.run_classical(noise_to_expval)
zne_expval = richardson_fac.reduce()
print(f"Error with richardson_fac: {abs(exact - zne_expval):.4f}")

poly_fac.run_classical(noise_to_expval)
zne_expval = poly_fac.reduce()
print(f"Error with poly_fac: {abs(exact - zne_expval):.4f}")
```

:::{note}
With respect to `self.run`, the {meth}`.Factory.run_classical` method is much more flexible and
can be applied whenever the user is able to autonomously scale the noise level associated
to an expectation value. Indeed, the function `noise_to_expval` can represent any experiment
or any simulation in which noise can be artificially increased. The scenario
is therefore not restricted to quantum circuits but can be easily extended to
annealing devices or to gates which are controllable at a pulse level. In principle,
one could even use the {meth}`.Factory.run_classical` method to mitigate experiments which are
unrelated to quantum computing.
:::

+++

#### Defining a custom factory

If necessary, the user can modify an existing extrapolation methods by subclassing
one of the [built-in factories](zne-3-options.myst#extrapolation-methods-factory-objects).

Alternatively, a custom adaptive extrapolation method can be derived from the abstract class {class}`.AdaptiveFactory`.
In this case its core methods must be implemented:
{meth}`.AdaptiveFactory.next`, {meth}`.AdaptiveFactory.is_converged`, {meth}`.AdaptiveFactory.reduce`.

Note that in general `self.__init__` methods of abstract factories, if present, must be overridden.

A new non-adaptive method can instead be derived from the abstract {class}`.BatchedFactory` class.
In this case it is usually sufficient to override only the [`BatchedFactory.__init__`](https://mitiq.readthedocs.io/en/latest/_modules/mitiq/zne/inference.html#BatchedFactory) and
the {meth}`.BatchedFactory.extrapolate` methods, which are responsible for the initialization and for the
final zero-noise extrapolation, respectively.

```{code-cell} ipython3
from mitiq.zne.inference import BatchedFactory, LinearFactory
import numpy as np
from mitiq.zne.scaling.folding import fold_gates_at_random

class MyFactory(BatchedFactory):
  """Factory object implementing a linear extrapolation taking
  into account that the expectation value must be within a given
  interval. If the zero-noise limit falls outside the
  interval, its value is clipped.
  """

  def __init__(self, scale_factors, min_expval, max_expval):
     """
     Args:
        scale_factors: The noise scale factors at which
                       expectation values should be measured.
        min_expval: The lower bound for the expectation value.
        min_expval: The upper bound for the expectation value.
     """
     super(MyFactory, self).__init__(scale_factors)
     self._options = {"min_expval": min_expval, "max_expval": max_expval}

  @staticmethod
  def extrapolate(
     scale_factors, exp_values, min_expval, max_expval, full_output = False,
  ):
     """Fit a linear model and clip its zero-noise limit."""

     # Perform standard linear extrapolation
     result = LinearFactory.extrapolate(
        scale_factors, exp_values, full_output,
     )

     # Return the clipped zero-noise extrapolation.
     if not full_output:
        return np.clip(result, min_expval, max_expval)

     if full_output:
        # In this case "result" is a tuple of extrapolation data
        zne_limit = np.clip(result[0], min_expval, max_expval)
        return (zne_limit, *result[1:])
```

```{code-cell} ipython3
fac = MyFactory([1, 2, 3], min_expval=0.0, max_expval=2.0)
fac.run_classical(noise_to_expval)
assert np.isclose(fac.reduce(), 1.0, atol=0.1)

# Linear model with a large zero-noise limit
noise_to_large_expval = lambda x : noise_to_expval(x) + 10.0
fac.run_classical(noise_to_large_expval)
# assert the output is clipped to 2.0
assert np.isclose(fac.reduce(), 2.0)

# Check other methods of the factory work
fac.get_expectation_values()
fac.get_extrapolation_curve()
fac.get_optimal_parameters()
fac.get_parameters_covariance()
fac.get_scale_factors()
fac.get_zero_noise_limit()
fac.get_zero_noise_limit_error()
fac.plot_fit()
```

This custom factory can be used in exactly the same way as we have
shown in the previous section. By simply replacing {class}`.LinearFactory`
with `MyFactory` in all the previous code snippets, the new extrapolation
method will be applied.

+++

### Regression tools in `zne.inference`

In the body of the previous `MyFactory` example, we imported and used the {py:func}`.mitiq_polyfit` function.
This is simply a wrap of {py:func}`numpy.polyfit`, slightly adapted to the notion and to the error types
of Mitiq. This function can be used to fit a polynomial ansatz to the measured expectation values. This function performs
a least squares minimization which is **linear** (with respect to the coefficients) and therefore admits an algebraic solution.

Similarly, from {py:mod}`mitiq.zne.inference` one can also import {py:func}`.mitiq_curve_fit`,
which is instead a wrap of {py:func}`scipy.optimize.curve_fit`. Differently from {py:func}`.mitiq_polyfit`,
{py:func}`.mitiq_curve_fit` can be used with a generic (user-defined) ansatz.
Since the fit is based on a numerical **non-linear** least squares minimization, this method may fail to converge
or could be subject to numerical instabilities.
