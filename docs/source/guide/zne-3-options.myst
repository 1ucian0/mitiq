---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.11.1
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

# What additional options are available when using ZNE?

In the introductory section [How do I use ZNE?](zne-1-intro.myst), we used the function
{func}`execute_with_zne()` to evaluate error-mitigated expectation values with zero-noise extrapolation.
Beyond the positional arguments (`circuit`, `executor` and `observable`) that are common to all
error mitigation techniques, one can use additional keyword arguments for optional settings as shown in next code snippet:

+++

```
from mitiq import zne

zne_value = zne.execute_with_zne(
    circuit,
    executor,
    observable,
    scale_noise = <"noise scaling method imported from zne.scaling">,
    factory = <"extrapolation Factory imported from zne.inference">,
    num_to_average = <"number of repeated evaluations for each noise-scaled circuit">,
)
```

+++

The three main options are `scale_noise`, `factory` and `num_to_average`.
- The option `scale_noise` can be used to select a noise scaling method.
    More details are explained below.
- The option `factory` can be used to select a an extrapolation method.
    More details are explained below.
- The option `num_to_average` can be used to average over multiple evaluations of each noise-scaled expectation value.

+++

In the next sections we explain in more details how noise scaling and extrapolation methods are represented in Mitiq 
and how they can be applied in practice.

+++

## Noise scaling functions

+++

To apply ZNE, we need to effectively increase the noise acting in a quantum computation. Instead of directly controlling the physical backend,
Mitiq achieves this task by *digital* noise scaling, i.e., with circuit manipulations that indirectly increase the effect of noise.
More details on digital ZNE can be found in [What is the theory behind ZNE?](zne-5-theory.myst)

In Mitiq a noise scaling method is represented by a *noise scaling function* that takes as input a `circuit` and a real `scale_factor` and
returns an `scaled_circuit`. For a noiseless backend, `scaled_circuit` has the same effect as `circuit`. For a noisy backend, 
`scaled_circuit` is more sensitive to errors depending on the magnitude of `scale_factor`. 

### Unitary Folding 

Mitiq provides several noise scaling functions. Most of them are based on the repeated application of the *unitary folding* technique in
which a unitary $G$ is mapped as follows:

$$G \longrightarrow G G^\dagger G.$$

If this is applied to individual gates of a `circuit`, we call it *local folding*. If $G$ is the entire `circuit`, we call it *global folding*.

The Mitiq function for global folding is:

- {func}`.fold_global()`.

The Mitiq functions for local folding are: 
- {func}`.fold_gates_at_random()`;
- {func}`.fold_gates_from_left()`;
- {func}`.fold_gates_from_right()`;
- {func}`.fold_all()`.

There are multiple functions for local folding since they can be applied to the gates of a circuit according to different orderings:
at random, from left (starting from the initial gates), from right (starting from the final gates), etc.. 
For more details on folding functions, we suggest to click on the functions listed above, to open the associated API docs.
If not specified by the user, the default noise scaling method in Mitiq is {func}`.fold_gates_at_random()`.

+++

**Note:** *All folding functions can be applied to circuits defined in any supported frontend. For example, in the next code cells we use Cirq to define quantum circuits.*

+++

#### The special case of odd integer scale factors

+++

Both local or global folding, if applied uniformly to all the gates of `circuit`, produce a `scaled_circuit` that has 3 times more gates than the input `circuit`.
This corresponds to the `scale_factor=3` setting. For example:

```{code-cell} ipython3
import cirq
from mitiq import zne

# Get a circuit to fold
qreg = cirq.LineQubit.range(2)
circuit = cirq.Circuit(cirq.ops.H.on(qreg[0]), cirq.ops.CNOT.on(qreg[0], qreg[1]))
print("Original circuit:", circuit, sep="\n")

# Apply local folding
scaled_circuit = zne.scaling.fold_gates_at_random(circuit, scale_factor=3)
print("Locally folded circuit:", scaled_circuit, sep="\n")

# Apply global folding
scaled_circuit = zne.scaling.fold_global(circuit, scale_factor=3)
print("Globally folded circuit:", scaled_circuit, sep="\n")
```

The same trick can be generalized to any odd integer `scale_factor`.
In this case, folding functions apply the mapping $G \longrightarrow G (G^\dagger G)^ {(\text{scale_factor} - 1)/2}$. For example:

```{code-cell} ipython3
num_gates = len(list(circuit.all_operations()))
for scale_factor in [1, 3, 5, 7]:
    scaled_circuit = zne.scaling.fold_global(circuit, scale_factor)
    scaled_num_gates = len(list(scaled_circuit.all_operations()))
    print(f"For scale_factor={scale_factor}, the number of gates was scaled by {scaled_num_gates / num_gates}")
```

**Note:** When `scale_factor` is an odd integer, the number of gates is scaled exactly as dictated by the value of `scale_factor`.
In this case, since all gates are folded the same number of times, the three local folding functions 
{func}`.fold_gates_at_random()`, {func}`.fold_gates_from_left()` and {func}`.fold_gates_from_right()` have the same deterministic action.

+++

#### The general case of real scale factors

+++

More generally, the `scale_factor` can be set to any real number larger or equal than one. In this case,
Mitiq applies additional folding to a selection of gates (for local folding) or to a final fraction of the circuit (for global folding), such that the total number of gates is *approximately* scaled by `scale_factor`. For example:

```{code-cell} ipython3
num_gates = len(list(circuit.all_operations()))
for scale_factor in [1.2, 1.4, 1.6, 1.8, 2.0]:
    scaled_circuit = zne.scaling.fold_gates_at_random(circuit, scale_factor)
    scaled_num_gates = len(list(scaled_circuit.all_operations()))
    print(f"For scale_factor={scale_factor}, the number of gates was scaled by {scaled_num_gates / num_gates}")
```

**Note:** As printed above, if `scale_factor` is not an odd integer and if the input circuit is very short, there can be a large error in the actual scaling of the number of gates.
For this reason, when dealing with very short circuits, we suggest to use odd integer scale factors.

+++

For longer circuits, real scale factors are better approximated.

```{code-cell} ipython3
long_circuit = circuit * 5
num_gates = len(list(long_circuit.all_operations()))
for scale_factor in [1.2, 1.4, 1.6, 1.8, 2.0]:
    scaled_circuit = zne.scaling.fold_gates_at_random(long_circuit, scale_factor)
    scaled_num_gates = len(list(scaled_circuit.all_operations()))
    print(f"For scale_factor={scale_factor} the number of gates was scaled by {scaled_num_gates / num_gates}")
```

#### Folding gates by fidelity

In local folding methods, gates can be folded according to custom fidelities by
passing the keyword argument `fidelities` into a local folding method. This
argument should be a dictionary where each key is a string which specifies the
gate and the value of the key is the fidelity of that gate. An example is shown
below where we set the fidelity of all single qubit gates to be 1.0, meaning that
these gates introduce negligible errors in the computation.

```{code-cell} ipython3
# Define test circuit
qreg = cirq.LineQubit.range(3)
test_circuit = cirq.Circuit((
    cirq.ops.H.on_each(*qreg),
    cirq.ops.CNOT.on(qreg[0], qreg[1]),
    cirq.ops.T.on(qreg[2]),
    cirq.ops.TOFFOLI.on(*qreg)
    
))
print("Original circuit:", test_circuit, "", sep="\n")

# Fold by fidelities
folded = zne.scaling.fold_gates_at_random(
    test_circuit, scale_factor=3, fidelities={"single": 1.0, "CNOT": 0.99, "TOFFOLI": 0.95},
)
print("Folded circuit:", folded, sep="\n")
```

We can see that only the two-qubit gates and three-qubit gates have been folded.

Specific gate keys override the global `"single"`, `"double"`, or `"triple"` options. For example, the dictionary
`fidelities = {"single": 1.0, "H": 0.99}` sets all single qubit gates to fidelity one except the Hadamard gate.


A full list of string keys for gates can be found with `help(fold_method)` where `fold_method` is a valid local
folding method. Fidelity values must be between zero and one.

+++

## Extrapolation methods: Factory objects

Extrapolation methods are represented in Mitiq as {class}`.Factory` objects.

```{code-cell} ipython3

```
