---
jupytext:
  text_representation:
    extension: .myst
    format_name: myst
    format_version: 0.13
    jupytext_version: 1.10.3
kernelspec:
  display_name: Python 3 (ipykernel)
  language: python
  name: python3
---

# How do I use ZNE?

Zero noise extrapolation is an error mitigation technique in which an expectation value is computed at different noise levels and, as a second step, the ideal expectation value is inferred extrapolating the measured results to the zero-noise limit.

Both steps — noise scaling and extrapolation — can be applied with Mitiq. The corresponding sub-modules are `mitiq.zne.scaling` and `mitiq.zne.inference`.

The following code is compatible with the multiple frontends. The next code cell can be used for selecting one of them.

```{code-cell} ipython3
frontend = "cirq"  # Supported: "cirq", "qiskit", "pyquil", "braket", "pennylane".
```

## Define the circuit of interest

+++

We first define the circuit of interest. For simplicity, in this example we use
a randomized-benchmarking circuit whose ideal execution is equivalent to the
identity operation.

```{code-cell} ipython3
from mitiq import benchmarks

circuit = benchmarks.generate_rb_circuits(
  n_qubits=1, num_cliffords=2, return_type = frontend,
)[0]

print(circuit)
```

## Define the executor function
We refer to a user-defined function that inputs a quantum program and executes it on a backend as an executor. 
Such functions always accept a quantum program, sometimes accept other arguments, and always return an expectation value as a float. 
As an example, below we define a simple executor function which inputs a Cirq circuit, executes it on a noisy simulator, and returns the probability of the ground state.

```{code-cell} ipython3
import numpy as np
from cirq import DensityMatrixSimulator, depolarize
from mitiq.interface import convert_to_mitiq

def executor(circuit, noise_level=0.01):
    """Returns Tr[ρ |0⟩⟨0|] where ρ is the state prepared by the circuit
    executed with depolarizing noise.
    """
    # Replace with code based on your frontend and backend.
    mitiq_circuit, _ = convert_to_mitiq(circuit)
    noisy_circuit = mitiq_circuit.with_noise(depolarize(p=noise_level))
    rho = DensityMatrixSimulator().simulate(noisy_circuit).final_density_matrix
    return rho[0, 0].real
```

The `executor` can be used to evaluate noisy (unmitigated) expectation values.

```{code-cell} ipython3
# Compute the expectation value of the |0><0| observable.
noisy_value = executor(circuit)
ideal_value = executor(circuit, noise_level=0.0)      
print(f"Error without mitigation: {abs(ideal_value - noisy_value) :.5f}")
```

## Select a noise scaling method
In Mitiq, folding functions input a circuit and a scale factor, i.e., 
a floating point value which corresponds to (approximately) how much the length 
of the circuit is scaled. The minimum scale factor is one (which corresponds to folding no gates). 
A scale factor of three corresponds to folding all gates locally. 
Scale factors beyond three begin to fold gates more than once.

+++

For local folding, there is a degree of freedom for which gates to fold first. 
The order in which gates are folded can have an important effect on how the noise is scaled. 
The function `fold_gates_from_left` will fold gates from the left (or start) of the 
circuit until the desired scale factor is reached.

```{code-cell} ipython3
from mitiq.zne.scaling import fold_gates_at_random
folded = fold_gates_at_random(circuit, scale_factor=2.)
print("Folded circuit:", folded, sep="\n")
```



## Select a noise extrapolation method 
Define a `Factory` object to select the noise extrapolation method and the noise scale factors.
For example, a linear extrapolation method with scale factors 1 and 2, can be initialized as follows:

```{code-cell} ipython3
from mitiq.zne.inference import LinearFactory
linear_fac = LinearFactory(scale_factors=[1.0, 2.0])
```

## Apply ZNE
Zero-noise extrapolation can be easily implemented with the function `mitiq.zne.zne.execute_with_zne()`.

```{code-cell} ipython3
from mitiq import zne
mitigated_result = zne.execute_with_zne(circuit, executor, factory=linear_fac, 
 scale_noise=fold_gates_at_random)
```

```{code-cell} ipython3
print(f"Error with mitigation (ZNE): {abs(ideal_value - mitigated_result):.{3}}")
```

Here we observe that the application of ZNE reduces the estimation error when compared to the unmitigated result.
